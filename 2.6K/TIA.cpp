#include "TIA.h"

int num = 128;
int tia_colors[][3] = {
{0x00, 0x00, 0x00},{0x40, 0x40, 0x40},{0x6C, 0x6C, 0x6C},{0x90, 0x90, 0x90},{0xB0, 0xB0, 0xB0},{0xC8, 0xC8, 0xC8},{0xDC, 0xDC, 0xDC},{0xEC, 0xEC, 0xEC},
{0x44, 0x44, 0x00},{0x64, 0x64, 0x10},{0x84, 0x84, 0x24},{0xA0, 0xA0, 0x34},{0xB8, 0xB8, 0x40},{0xD0, 0xD0, 0x50},{0xE8, 0xE8, 0x5C},{0xFC, 0xFC, 0x68},
{0x70, 0x28, 0x00},{0x84, 0x44, 0x14},{0x98, 0x5C, 0x28},{0xAC, 0x78, 0x3C},{0xBC, 0x8C, 0x4C},{0xCC, 0xA0, 0x5C},{0xDC, 0xB4, 0x68},{0xEC, 0xC8, 0x78},
{0x84, 0x18, 0x00},{0x98, 0x34, 0x18},{0xAC, 0x50, 0x30},{0xC0, 0x68, 0x48},{0xD0, 0x80, 0x5C},{0xE0, 0x94, 0x70},{0xEC, 0xA8, 0x80},{0xFC, 0xBC, 0x94},
{0x88, 0x00, 0x00},{0x9C, 0x20, 0x20},{0xB0, 0x3C, 0x3C},{0xC0, 0x58, 0x58},{0xD0, 0x70, 0x70},{0xE0, 0x88, 0x88},{0xEC, 0xA0, 0xA0},{0xFC, 0xB4, 0xB4},
{0x78, 0x00, 0x5C},{0x8C, 0x20, 0x74},{0xA0, 0x3C, 0x88},{0xB0, 0x58, 0x9C},{0xC0, 0x70, 0xB0},{0xD0, 0x84, 0xC0},{0xDC, 0x9C, 0xD0},{0xEC, 0xB0, 0xE0},
{0x48, 0x00, 0x78},{0x60, 0x20, 0x90},{0x78, 0x3C, 0xA4},{0x8C, 0x58, 0xB8},{0xA0, 0x70, 0xCC},{0xB4, 0x84, 0xDC},{0xC4, 0x9C, 0xEC},{0xD4, 0xB0, 0xFC},
{0x14, 0x00, 0x84},{0x30, 0x20, 0x98},{0x4C, 0x3C, 0xAC},{0x68, 0x58, 0xC0},{0x7C, 0x70, 0xD0},{0x94, 0x88, 0xE0},{0xA8, 0xA0, 0xEC},{0xBC, 0xB4, 0xFC},
{0x00, 0x00, 0x88},{0x1C, 0x20, 0x9C},{0x38, 0x40, 0xB0},{0x50, 0x5C, 0xC0},{0x68, 0x74, 0xD0},{0x7C, 0x8C, 0xE0},{0x90, 0xA4, 0xEC},{0xA4, 0xB8, 0xFC},
{0x00, 0x18, 0x7C},{0x1C, 0x38, 0x90},{0x38, 0x54, 0xA8},{0x50, 0x70, 0xBC},{0x68, 0x88, 0xCC},{0x7C, 0x9C, 0xDC},{0x90, 0xB4, 0xEC},{0xA4, 0xC8, 0xFC},
{0x00, 0x2C, 0x5C},{0x1C, 0x4C, 0x78},{0x38, 0x68, 0x90},{0x50, 0x84, 0xAC},{0x68, 0x9C, 0xC0},{0x7C, 0xB4, 0xD4},{0x90, 0xCC, 0xE8},{0xA4, 0xE0, 0xFC},
{0x00, 0x3C, 0x2C},{0x1C, 0x5C, 0x48},{0x38, 0x7C, 0x64},{0x50, 0x9C, 0x80},{0x68, 0xB4, 0x94},{0x7C, 0xD0, 0xAC},{0x90, 0xE4, 0xC0},{0xA4, 0xFC, 0xD4},
{0x00, 0x3C, 0x00},{0x20, 0x5C, 0x20},{0x40, 0x7C, 0x40},{0x5C, 0x9C, 0x5C},{0x74, 0xB4, 0x74},{0x8C, 0xD0, 0x8C},{0xA4, 0xE4, 0xA4},{0xB8, 0xFC, 0xB8},
{0x14, 0x38, 0x00},{0x34, 0x5C, 0x1C},{0x50, 0x7C, 0x38},{0x6C, 0x98, 0x50},{0x84, 0xB4, 0x68},{0x9C, 0xCC, 0x7C},{0xB4, 0xE4, 0x90},{0xC8, 0xFC, 0xA4},
{0x2C, 0x30, 0x00},{0x4C, 0x50, 0x1C},{0x68, 0x70, 0x34},{0x84, 0x8C, 0x4C},{0x9C, 0xA8, 0x64},{0xB4, 0xC0, 0x78},{0xCC, 0xD4, 0x88},{0xE0, 0xEC, 0x9C},
{0x44, 0x28, 0x00},{0x64, 0x48, 0x18},{0x84, 0x68, 0x30},{0xA0, 0x84, 0x44},{0xB8, 0x9C, 0x58},{0xD0, 0xB4, 0x6C},{0xE8, 0xCC, 0x7C},{0xFC, 0xE0, 0x8C}
};

void TIA::init_screen(int h, int w)
{
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		return;
	}

	m_window = SDL_CreateWindow(
		"hello_sdl2",
		SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
		w, h,
		SDL_WINDOW_SHOWN
	);
	m_screen = SDL_GetWindowSurface(m_window);
	SDL_FillRect(m_screen, NULL, SDL_MapRGB(m_screen->format, 0xFF, 0xFF, 0xFF));
	SDL_UpdateWindowSurface(m_window);

	m_renderer = SDL_CreateRenderer(m_window, -1, SDL_RENDERER_ACCELERATED);
	m_texture = SDL_CreateTexture(m_renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, w, h);

	m_w = w * PIXEL_WIDTH;
	m_h = h * PIXEL_HEIGHT;
	m_pixels = new Uint32[m_w * m_h];
	memset(m_pixels, 255, m_w * m_h * sizeof(Uint32));

	m_claimed = new PIXEL_LEVEL[m_w * m_h];
	memset(m_claimed, NONE, m_w * m_h * sizeof(PIXEL_LEVEL));
};

TIA::~TIA()
{
	if (m_pixels)
		delete[] m_pixels;

	if (m_window){
		SDL_DestroyWindow(m_window);
		SDL_Quit();
	}
}


TIA_FLAG TIA::tick()
{


	//Check registers (for wsync, etc.)
	TIA_FLAG ret = check_registers();
	
	if (cur_scanline <= VSYNC)
		//VSYNC
		;
	else if (cur_scanline <= VBLANK)
		//VBLANK
		;
	else if (cur_scanline <= OVERSCAN)
	{
		if (cur_clock > HBLANK)
		{
			draw_playfield();
			draw_background();
		}

		if (cur_scanline == OVERSCAN && cur_clock >= 228){
			SDL_UpdateTexture(m_texture, NULL, m_pixels, m_w * sizeof(Uint32));
			SDL_RenderClear(m_renderer);
			SDL_RenderCopy(m_renderer, m_texture, NULL, NULL);
			SDL_RenderPresent(m_renderer);
			memset(m_pixels, 255, m_w * m_h * sizeof(Uint32));
			memset(m_claimed, NONE, m_w * m_h * sizeof(PIXEL_LEVEL));
		}
	}


	if (cur_scanline >= OVERSCAN && cur_clock >= 228)
	{
		
		cur_clock = 1;
		cur_scanline = 1;
		if (cpu_wait)
		{
			cpu_wait = false;
			return CPU_WAKEUP;
		}
		else
		{
			return OK;
		}

	}
	else if (cur_clock >= 228)
	{
		cur_scanline += 1;
		cur_clock = 0;
		if (cpu_wait)
		{
			cpu_wait = false;
			return CPU_WAKEUP;
		}
		else
		{
			return OK;
		}
	}
	else 
	{
		cur_clock++;
	}

	return ret;

}

void TIA::draw_background()
{
	//Read Color
	uint8_t color = m_mem->read_tia(COLUBK);	
	
	//SDL_SetRenderDrawColor(m_renderer, tia_colors[color/2%num][0], tia_colors[color/2%num][1], tia_colors[color/2%num][2], 255);
	//SDL_RenderClear(m_renderer);

//	if (last_pf + 1 >= (cur_clock - HBLANK - 1))
//		return;

	int x = (cur_clock - HBLANK - 1) * PIXEL_WIDTH;
	int y = (cur_scanline - VBLANK - 1);

	if (m_claimed[x] != NONE || m_claimed[x+1] != NONE)
		return;

	draw_pixel(x, y,  tia_colors[color / 2][0], tia_colors[color / 2][1], tia_colors[color / 2][2]);
	draw_pixel(x + 1, y, tia_colors[color / 2][0], tia_colors[color / 2][1], tia_colors[color / 2][2]);
	//SDL_RenderDrawPoint(m_renderer, (cur_clock - HBLANK - 1) * 2, cur_scanline - VBLANK - 1);
	//SDL_RenderDrawPoint(m_renderer, (cur_clock - HBLANK - 1) * 2 + 1, cur_scanline - VBLANK - 1);
}

void TIA::draw_playfield()
{
	//Read color
	uint8_t color = m_mem->read_tia(COLUPF);

	int pf_bit = std::ceil((cur_clock - HBLANK) / 4) - 1;
	int shift = pf_bit >= 20 ? pf_bit - 20 : pf_bit;

	uint8_t draw_pf_pixel = 0;

	uint8_t mirror = m_mem->read_tia(CTRLPF) & REF;
	
	int index = pf_bit;
	if (mirror && pf_bit >= 20) {
		int index = pf_bit;
		pf_bit = 40 - pf_bit - 1;
		if (m_claimed[pf_bit*PF_WIDTH] != PF) {
			for (int i = 0; i < PF_WIDTH; i++) {
				m_claimed[index * PF_WIDTH + i] = NONE;
			}
			return;
		}

		for (int i = 0; i < PF_WIDTH; i++) {
			draw_pixel(index*PF_WIDTH + i, cur_scanline - VBLANK - 1, tia_colors[color / 2][0], tia_colors[color / 2][1], tia_colors[color / 2][2]);
			m_claimed[index* PF_WIDTH + i] = PF;
		}

		return;
	}


	//PF0
	if ((pf_bit >= 0 && pf_bit < 4) || (pf_bit >= 20 && pf_bit < 24)){
		shift = 3 - shift;
		//if(!mirror || pf_bit < 4)
		//	shift = 3 - shift;
		draw_pf_pixel = m_mem->read_tia(PF0) & (0b10000000 >> (shift));
	}

	//PF1
	if ((pf_bit >= 4 && pf_bit < 12) || (pf_bit >= 24 && pf_bit < 32)){
		draw_pf_pixel = m_mem->read_tia(PF1) & (0b10000000 >> (shift - 4));
	}

	//PF2
	if ((pf_bit >= 12 && pf_bit < 20) || (pf_bit >= 32)){
		draw_pf_pixel = m_mem->read_tia(PF2) & (0b10000000 >> (shift - 12));
	}

	if (draw_pf_pixel || last_pf == pf_bit){

		last_pf = pf_bit;
		for (int i = 0; i < PF_WIDTH; i++) {
			draw_pixel(pf_bit * PF_WIDTH + i, cur_scanline - VBLANK - 1, tia_colors[color / 2][0], tia_colors[color / 2][1], tia_colors[color / 2][2]);
			m_claimed[pf_bit * PF_WIDTH + i] = PF;
		}
	}
	else {
		for (int i = 0; i < PF_WIDTH; i++) {
			m_claimed[pf_bit * PF_WIDTH + i] = NONE;
		}
	}
}

TIA_FLAG TIA::check_registers()
{
	if (m_mem->read_tia(WSYNC))
	{
		m_mem->clear(WSYNC);
		cpu_wait = true;
		return CPU_SLEEP;
	}
	return OK;
}

void TIA::draw_pixel(int x, int y, uint8_t r, uint8_t g, uint8_t b)
{
	m_pixels[y * m_w + x] = ((((((255 << 8) + r) << 8) + g) << 8) + b);
}